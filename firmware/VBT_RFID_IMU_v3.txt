/*
  VBT_RFID_IMU_v3.ino
  ESP32-S3 + QMI8658 IMU + ST7789 Display + WiFi/Supabase + RC522 RFID

  Based on v2 — adds:
    - WiFi connection + Supabase REST API uploads
    - RC522 RFID tag scanning to identify players
    - Rep buffering (upload on set end)
    - NTP time sync for accurate timestamps
    - Non-blocking serial command parser (multi-char commands)
    - Auto WiFi reconnect

  Hardware:
    IMU:     I2C  SDA=GPIO47, SCL=GPIO48, Addr=0x6B
    Display: FSPI (SPI3) CS=10, DC=8, RST=14, BL=15, SCK=12, MOSI=11
    RC522:   HSPI (SPI2) SS=4, SCK=5, MOSI=6, MISO=7, RST=16

  Libraries needed (Arduino Library Manager):
    1. "Adafruit GFX Library" by Adafruit
    2. "Adafruit ST7735 and ST7789 Library" by Adafruit
    3. "ArduinoJson" by Benoit Blanchon
    4. "MFRC522" by GithubCommunity

  Serial Commands:
    s           = Start set
    x           = Stop set + upload to Supabase
    c           = Calibrate IMU (hold still ~1 second)
    e:<name>    = Change exercise (e.g. e:Bench Press)
    p:<uuid>    = Change active player ID
    t:<uuid>    = Change active team ID
    d           = Delete last uploaded set (all 3 tables)
    w           = Print WiFi + Supabase connection status
*/

#include <Wire.h>
#include <math.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ST7789.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <MFRC522.h>
#include <time.h>

// ══════════════════════════════════════════════════════════════════════
//  USER CONFIGURATION — edit these before uploading
// ══════════════════════════════════════════════════════════════════════
const char* WIFI_SSID     = "YOUR_SSID";
const char* WIFI_PASS     = "YOUR_PASSWORD";
const char* SUPABASE_URL  = "https://mbabcboecbtagnycmbti.supabase.co";
const char* SUPABASE_KEY  = "PASTE_ANON_KEY_HERE";

// Hardcoded test IDs — replace with real UUIDs from your database
String activePlayerId = "paste-a-real-player-uuid";
String activeTeamId   = "paste-a-real-team-uuid";
String activeExercise = "Back Squat";

// ══════════════════════════════════════════════════════════════════════
//  DISPLAY (ST7789 240x240 on FSPI / SPI3)
// ══════════════════════════════════════════════════════════════════════
#define TFT_CS   10
#define TFT_DC    8
#define TFT_RST  14
#define TFT_BL   15
#define TFT_SCK  12
#define TFT_MOSI 11

Adafruit_ST7789 tft = Adafruit_ST7789(TFT_CS, TFT_DC, TFT_RST);

#define C_BLACK   ST77XX_BLACK
#define C_WHITE   ST77XX_WHITE
#define C_GREEN   ST77XX_GREEN
#define C_YELLOW  ST77XX_YELLOW
#define C_CYAN    ST77XX_CYAN
#define C_RED     ST77XX_RED
#define C_GREY    0x7BEF

bool displayDirty = true;

struct LastRepData {
  int    repNum;
  float  peakVel;
  float  meanVel;
  float  peakAccel;
  float  romCm;
  int    concMs;
  int    eccMs;
  int    totalMs;
} lastRep = {0, 0, 0, 0, 0, 0, 0, 0};

int lastSetReps = 0;

// ══════════════════════════════════════════════════════════════════════
//  RC522 RFID (HSPI / SPI2)
// ══════════════════════════════════════════════════════════════════════
#define RFID_SS    4
#define RFID_RST_PIN  16   // GPIO16 for RFID reset (GPIO15 used by TFT_BL)
#define RFID_SCK   5
#define RFID_MOSI  6
#define RFID_MISO  7

SPIClass hspi(HSPI);
MFRC522  mfrc522(RFID_SS, RFID_RST_PIN);

unsigned long lastRfidCheckMs = 0;
const unsigned long RFID_CHECK_INTERVAL = 300;  // ms between scans

// ══════════════════════════════════════════════════════════════════════
//  IMU (QMI8658)
// ══════════════════════════════════════════════════════════════════════
static const int I2C_SDA = 47;
static const int I2C_SCL = 48;
static const uint8_t QMI_ADDR = 0x6B;

static const uint8_t REG_WHO_AM_I = 0x00;
static const uint8_t REG_CTRL1    = 0x02;
static const uint8_t REG_CTRL2    = 0x03;
static const uint8_t REG_CTRL3    = 0x04;
static const uint8_t REG_CTRL5    = 0x06;
static const uint8_t REG_CTRL7    = 0x08;
static const uint8_t REG_AX_L     = 0x35;

static const float G_CONST = 9.80665f;
static const float ACC_LSB_PER_G = 4096.0f;
static const float GYRO_LSB_PER_DPS = 32.0f;

// ══════════════════════════════════════════════════════════════════════
//  I2C HELPERS
// ══════════════════════════════════════════════════════════════════════
static inline int16_t le16(const uint8_t *p) {
  return (int16_t)((uint16_t)p[0] | ((uint16_t)p[1] << 8));
}

bool writeReg(uint8_t reg, uint8_t val) {
  Wire.beginTransmission(QMI_ADDR);
  Wire.write(reg);
  Wire.write(val);
  return Wire.endTransmission() == 0;
}

bool readReg(uint8_t reg, uint8_t &val) {
  Wire.beginTransmission(QMI_ADDR);
  Wire.write(reg);
  if (Wire.endTransmission(false) != 0) return false;
  if (Wire.requestFrom((int)QMI_ADDR, 1) != 1) return false;
  val = Wire.read();
  return true;
}

bool readBytes(uint8_t startReg, uint8_t *buf, size_t n) {
  Wire.beginTransmission(QMI_ADDR);
  Wire.write(startReg);
  if (Wire.endTransmission(false) != 0) return false;
  if (Wire.requestFrom((int)QMI_ADDR, (int)n) != (int)n) return false;
  for (size_t i = 0; i < n; i++) buf[i] = Wire.read();
  return true;
}

void setupQMI8658() {
  writeReg(REG_CTRL1, 0x60);
  writeReg(REG_CTRL2, 0x23);
  writeReg(REG_CTRL3, 0x63);
  writeReg(REG_CTRL5, 0x11);
  writeReg(REG_CTRL7, 0x03);
  delay(50);
}

bool readIMU(float &ax, float &ay, float &az, float &gx, float &gy, float &gz) {
  uint8_t buf[12];
  if (!readBytes(REG_AX_L, buf, sizeof(buf))) return false;
  ax = (le16(&buf[0])  / ACC_LSB_PER_G) * G_CONST;
  ay = (le16(&buf[2])  / ACC_LSB_PER_G) * G_CONST;
  az = (le16(&buf[4])  / ACC_LSB_PER_G) * G_CONST;
  gx = le16(&buf[6])  / GYRO_LSB_PER_DPS;
  gy = le16(&buf[8])  / GYRO_LSB_PER_DPS;
  gz = le16(&buf[10]) / GYRO_LSB_PER_DPS;
  return true;
}

// ══════════════════════════════════════════════════════════════════════
//  VBT STATE
// ══════════════════════════════════════════════════════════════════════
enum DeviceState { IDLE, RUNNING, CALIBRATING };
DeviceState state = IDLE;

float gex = 0, gey = 0, gez = G_CONST;
float biasGx = 0, biasGy = 0, biasGz = 0;
bool calibrated = false;

float vVert = 0;
float dVert = 0;
unsigned long lastMicros = 0;

const float COMP_ALPHA     = 0.02f;
const float ACC_DEADBAND   = 0.12f;
const float VEL_DECAY      = 0.998f;
const float VEL_CLAMP      = 6.0f;

const float ZUPT_ACCEL_THRESH = 0.25f;
const float ZUPT_GYRO_THRESH  = 5.0f;
const int   ZUPT_COUNT_THRESH = 40;
int zuptCounter = 0;

enum Phase { REST = 0, CONCENTRIC = 1, ECCENTRIC = 2 };
Phase phase = REST;
int repCount = 0;

const float CONC_START_THRESH  = 0.15f;
const float CONC_END_THRESH    = 0.05f;
const float ECC_MOVE_THRESH    = -0.10f;
const float ECC_END_THRESH     = 0.03f;
const float MIN_CONC_MS        = 100.0f;
const float MIN_ECC_MS         = 100.0f;
const float MIN_REST_MS        = 120.0f;
const float MIN_ROM_CM         = 3.0f;

unsigned long concStartMs = 0;
unsigned long concEndMs   = 0;
float concPeakVel   = 0;
float concSumVel    = 0;
unsigned long concSamples = 0;
float concPeakAccel = 0;
float concDisplacement = 0;

unsigned long eccStartMs = 0;
float eccPeakVel    = 0;
float eccSumVel     = 0;
unsigned long eccSamples = 0;
float eccDisplacement = 0;

unsigned long lastRepEndMs = 0;

float repAccelMin = 999, repAccelMax = 0, repAccelSum = 0;
float repGyroMin  = 999, repGyroMax  = 0, repGyroSum  = 0;
unsigned long repTotalSamples = 0;

const int SMA_SIZE = 5;
float smaBuffer[SMA_SIZE];
int smaIndex = 0;
bool smaFull = false;

float smaFilter(float val) {
  smaBuffer[smaIndex] = val;
  smaIndex = (smaIndex + 1) % SMA_SIZE;
  if (!smaFull && smaIndex == 0) smaFull = true;
  int count = smaFull ? SMA_SIZE : smaIndex;
  if (count == 0) return val;
  float sum = 0;
  for (int i = 0; i < count; i++) sum += smaBuffer[i];
  return sum / (float)count;
}

// ══════════════════════════════════════════════════════════════════════
//  REP BUFFER (for Supabase upload on set end)
// ══════════════════════════════════════════════════════════════════════
const int MAX_REPS_PER_SET = 30;

struct RepData {
  int   rep_number;
  float mean_velocity;
  float peak_velocity;
  float rom_meters;
  float concentric_duration;   // seconds
  float eccentric_duration;    // seconds
  float time_to_peak_vel;      // seconds (concentric only)
};

RepData repBuffer[MAX_REPS_PER_SET];
int repBufferCount = 0;

// Set timing
unsigned long setStartMs = 0;
String setStartedAtISO = "";
String lastUploadedSetId = "";   // for delete command

// ══════════════════════════════════════════════════════════════════════
//  WiFi + NTP
// ══════════════════════════════════════════════════════════════════════
bool wifiConnected = false;
unsigned long lastWifiCheckMs = 0;
const unsigned long WIFI_CHECK_INTERVAL = 10000;  // check every 10s

void connectWiFi() {
  Serial.print("WiFi: Connecting to ");
  Serial.print(WIFI_SSID);
  Serial.print("...");

  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 40) {
    delay(250);
    Serial.print(".");
    attempts++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    Serial.println(" OK!");
    Serial.print("  IP: ");
    Serial.println(WiFi.localIP());

    // Sync NTP time
    configTime(0, 0, "pool.ntp.org", "time.nist.gov");
    Serial.print("  NTP sync...");
    struct tm timeinfo;
    int ntpAttempts = 0;
    while (!getLocalTime(&timeinfo) && ntpAttempts < 10) {
      delay(500);
      Serial.print(".");
      ntpAttempts++;
    }
    if (ntpAttempts < 10) {
      char buf[30];
      strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%SZ", &timeinfo);
      Serial.print(" OK! Time: ");
      Serial.println(buf);
    } else {
      Serial.println(" FAILED (timestamps will use millis)");
    }
  } else {
    wifiConnected = false;
    Serial.println(" FAILED!");
    Serial.println("  Data will NOT upload. Check SSID/password.");
  }
}

void checkWiFiReconnect() {
  unsigned long now = millis();
  if (now - lastWifiCheckMs < WIFI_CHECK_INTERVAL) return;
  lastWifiCheckMs = now;

  if (WiFi.status() != WL_CONNECTED) {
    if (wifiConnected) {
      Serial.println("WiFi: Connection lost! Reconnecting...");
      wifiConnected = false;
    }
    WiFi.disconnect();
    WiFi.begin(WIFI_SSID, WIFI_PASS);
    delay(500);
    if (WiFi.status() == WL_CONNECTED) {
      wifiConnected = true;
      Serial.println("WiFi: Reconnected!");
    }
  } else if (!wifiConnected) {
    wifiConnected = true;
    Serial.println("WiFi: Connected!");
  }
}

// Get current time as ISO 8601 string
String getISOTimestamp() {
  struct tm timeinfo;
  if (getLocalTime(&timeinfo)) {
    char buf[30];
    strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%SZ", &timeinfo);
    return String(buf);
  }
  // Fallback: return millis-based placeholder
  return "1970-01-01T00:00:" + String(millis() / 1000) + "Z";
}

// ══════════════════════════════════════════════════════════════════════
//  SUPABASE HTTP HELPERS
// ══════════════════════════════════════════════════════════════════════
struct HttpResult {
  bool   success;
  int    httpCode;
  String body;
};

HttpResult supabasePost(const char* table, const String& jsonPayload) {
  HttpResult result = {false, 0, ""};

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("  [HTTP] No WiFi — skipping POST");
    return result;
  }

  HTTPClient http;
  String url = String(SUPABASE_URL) + "/rest/v1/" + table;
  http.begin(url);
  http.addHeader("apikey", SUPABASE_KEY);
  http.addHeader("Authorization", String("Bearer ") + SUPABASE_KEY);
  http.addHeader("Content-Type", "application/json");
  http.addHeader("Prefer", "return=representation");

  result.httpCode = http.POST(jsonPayload);
  if (result.httpCode >= 200 && result.httpCode < 300) {
    result.success = true;
    result.body = http.getString();
  } else {
    result.body = http.getString();
    Serial.print("  [HTTP] POST ");
    Serial.print(table);
    Serial.print(" failed: ");
    Serial.print(result.httpCode);
    Serial.print(" ");
    Serial.println(result.body);
  }

  http.end();
  return result;
}

HttpResult supabaseDelete(const char* table, const char* matchColumn, const String& matchValue) {
  HttpResult result = {false, 0, ""};

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("  [HTTP] No WiFi — skipping DELETE");
    return result;
  }

  HTTPClient http;
  String url = String(SUPABASE_URL) + "/rest/v1/" + table
             + "?" + matchColumn + "=eq." + matchValue;
  http.begin(url);
  http.addHeader("apikey", SUPABASE_KEY);
  http.addHeader("Authorization", String("Bearer ") + SUPABASE_KEY);

  result.httpCode = http.sendRequest("DELETE");
  if (result.httpCode >= 200 && result.httpCode < 300) {
    result.success = true;
  } else {
    result.body = http.getString();
    Serial.print("  [HTTP] DELETE ");
    Serial.print(table);
    Serial.print(" failed: ");
    Serial.print(result.httpCode);
    Serial.print(" ");
    Serial.println(result.body);
  }

  http.end();
  return result;
}

HttpResult supabaseGet(const String& urlPath) {
  HttpResult result = {false, 0, ""};

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("  [HTTP] No WiFi — skipping GET");
    return result;
  }

  HTTPClient http;
  String url = String(SUPABASE_URL) + "/rest/v1/" + urlPath;
  http.begin(url);
  http.addHeader("apikey", SUPABASE_KEY);
  http.addHeader("Authorization", String("Bearer ") + SUPABASE_KEY);

  result.httpCode = http.GET();
  if (result.httpCode >= 200 && result.httpCode < 300) {
    result.success = true;
    result.body = http.getString();
  } else {
    result.body = http.getString();
    Serial.print("  [HTTP] GET failed: ");
    Serial.print(result.httpCode);
    Serial.print(" ");
    Serial.println(result.body);
  }

  http.end();
  return result;
}

// ══════════════════════════════════════════════════════════════════════
//  SUPABASE UPLOAD (called on set end)
// ══════════════════════════════════════════════════════════════════════
void uploadSet() {
  if (repBufferCount == 0) {
    Serial.println("UPLOAD: No reps to upload.");
    return;
  }

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("UPLOAD: No WiFi — data NOT uploaded. Reps are lost.");
    return;
  }

  String endedAt = getISOTimestamp();

  Serial.println("UPLOAD: Starting...");

  // ── Step 1: Insert vbt_raw_sets ──
  JsonDocument rawSetDoc;
  rawSetDoc["player_id"]   = activePlayerId;
  rawSetDoc["team_id"]     = activeTeamId;
  rawSetDoc["exercise"]    = activeExercise;
  rawSetDoc["device_id"]   = nullptr;
  rawSetDoc["sample_rate"] = 200;
  rawSetDoc["samples"].to<JsonArray>();  // empty JSON array
  rawSetDoc["started_at"]  = setStartedAtISO;
  rawSetDoc["ended_at"]    = endedAt;
  rawSetDoc["processed"]   = false;

  String rawSetJson;
  serializeJson(rawSetDoc, rawSetJson);

  HttpResult res1 = supabasePost("vbt_raw_sets", rawSetJson);
  if (!res1.success) {
    Serial.println("UPLOAD: Failed at vbt_raw_sets — aborting.");
    return;
  }

  // Parse returned row to get the UUID
  JsonDocument resDoc;
  deserializeJson(resDoc, res1.body);
  String rawSetId = resDoc[0]["id"].as<String>();
  lastUploadedSetId = rawSetId;

  Serial.print("  raw_set_id: ");
  Serial.println(rawSetId);

  // ── Step 2: Insert vbt_reps (batch) ──
  JsonDocument repsDoc;
  JsonArray repsArr = repsDoc.to<JsonArray>();

  float firstRepVel = repBuffer[0].mean_velocity;

  for (int i = 0; i < repBufferCount; i++) {
    JsonObject rep = repsArr.add<JsonObject>();
    rep["raw_set_id"]           = rawSetId;
    rep["player_id"]            = activePlayerId;
    rep["exercise"]             = activeExercise;
    rep["rep_number"]           = repBuffer[i].rep_number;
    rep["mean_velocity"]        = round(repBuffer[i].mean_velocity * 1000.0f) / 1000.0f;
    rep["peak_velocity"]        = round(repBuffer[i].peak_velocity * 1000.0f) / 1000.0f;
    rep["rom_meters"]           = round(repBuffer[i].rom_meters * 1000.0f) / 1000.0f;
    rep["concentric_duration"]  = round(repBuffer[i].concentric_duration * 1000.0f) / 1000.0f;
    rep["eccentric_duration"]   = round(repBuffer[i].eccentric_duration * 1000.0f) / 1000.0f;
    rep["time_to_peak_vel"]     = round(repBuffer[i].time_to_peak_vel * 1000.0f) / 1000.0f;

    // Velocity loss % relative to first rep
    float vloss = 0;
    if (firstRepVel > 0 && i > 0) {
      vloss = (firstRepVel - repBuffer[i].mean_velocity) / firstRepVel * 100.0f;
    }
    rep["velocity_loss_pct"] = round(vloss * 10.0f) / 10.0f;
    rep["flagged"]           = false;
    rep["flag_reason"]       = nullptr;
    rep["bar_path_deviation"] = nullptr;
  }

  String repsJson;
  serializeJson(repsArr, repsJson);

  HttpResult res2 = supabasePost("vbt_reps", repsJson);
  if (!res2.success) {
    Serial.println("UPLOAD: Failed at vbt_reps (raw_set was created).");
  } else {
    Serial.print("  vbt_reps: ");
    Serial.print(repBufferCount);
    Serial.println(" inserted");
  }

  // ── Step 3: Insert vbt_set_summaries ──
  float sumVel = 0, peakVel = 0;
  for (int i = 0; i < repBufferCount; i++) {
    sumVel += repBuffer[i].mean_velocity;
    if (repBuffer[i].peak_velocity > peakVel) peakVel = repBuffer[i].peak_velocity;
  }
  float avgVel = sumVel / (float)repBufferCount;

  // Velocity loss: (rep1 - repN) / rep1 * 100
  float velocityLoss = 0;
  if (repBufferCount > 1 && firstRepVel > 0) {
    velocityLoss = (firstRepVel - repBuffer[repBufferCount - 1].mean_velocity) / firstRepVel * 100.0f;
  }

  bool flagged = (velocityLoss > 20.0f);

  JsonDocument summaryDoc;
  summaryDoc["raw_set_id"]    = rawSetId;
  summaryDoc["player_id"]     = activePlayerId;
  summaryDoc["exercise"]      = activeExercise;
  summaryDoc["rep_count"]     = repBufferCount;
  summaryDoc["avg_velocity"]  = round(avgVel * 1000.0f) / 1000.0f;
  summaryDoc["peak_velocity"] = round(peakVel * 1000.0f) / 1000.0f;
  summaryDoc["velocity_loss"] = round(velocityLoss * 10.0f) / 10.0f;
  summaryDoc["estimated_1rm"] = nullptr;
  summaryDoc["flagged"]       = flagged;
  summaryDoc["flag_reason"]   = flagged ? "velocity_loss>20%" : nullptr;

  String summaryJson;
  serializeJson(summaryDoc, summaryJson);

  HttpResult res3 = supabasePost("vbt_set_summaries", summaryJson);
  if (!res3.success) {
    Serial.println("UPLOAD: Failed at vbt_set_summaries.");
  } else {
    Serial.println("  vbt_set_summaries: inserted");
  }

  // ── Done ──
  Serial.println("UPLOAD: Complete!");
  Serial.print("  Set ID:        ");  Serial.println(rawSetId);
  Serial.print("  Reps:          ");  Serial.println(repBufferCount);
  Serial.print("  Avg velocity:  ");  Serial.print(avgVel, 3); Serial.println(" m/s");
  Serial.print("  Peak velocity: ");  Serial.print(peakVel, 3); Serial.println(" m/s");
  Serial.print("  Velocity loss: ");  Serial.print(velocityLoss, 1); Serial.println("%");
  if (flagged) Serial.println("  *** FLAGGED (velocity loss > 20%) ***");
}

// Delete last uploaded set from all 3 tables
void deleteLastSet() {
  if (lastUploadedSetId.length() == 0) {
    Serial.println("DELETE: No set to delete.");
    return;
  }

  Serial.print("DELETE: Removing set ");
  Serial.println(lastUploadedSetId);

  // Delete in reverse FK order: summaries, reps, then raw_set
  supabaseDelete("vbt_set_summaries", "raw_set_id", lastUploadedSetId);
  supabaseDelete("vbt_reps", "raw_set_id", lastUploadedSetId);
  supabaseDelete("vbt_raw_sets", "id", lastUploadedSetId);

  Serial.println("DELETE: Done.");
  lastUploadedSetId = "";
}

// ══════════════════════════════════════════════════════════════════════
//  RFID SCANNING
// ══════════════════════════════════════════════════════════════════════
void setupRFID() {
  hspi.begin(RFID_SCK, RFID_MISO, RFID_MOSI, RFID_SS);
  mfrc522.PCD_Init(RFID_SS, RFID_RST_PIN);
  delay(10);

  byte v = mfrc522.PCD_ReadRegister(MFRC522::VersionReg);
  if (v == 0x00 || v == 0xFF) {
    Serial.println("RFID: RC522 not detected (check wiring)");
  } else {
    Serial.print("RFID: RC522 firmware v");
    Serial.print(v, HEX);
    Serial.println(" — ready");
  }
}

String uidToHex(byte *uid, byte size) {
  String hex = "";
  for (byte i = 0; i < size; i++) {
    if (uid[i] < 0x10) hex += "0";
    hex += String(uid[i], HEX);
  }
  hex.toUpperCase();
  return hex;
}

void handleRFIDScan() {
  unsigned long now = millis();
  if (now - lastRfidCheckMs < RFID_CHECK_INTERVAL) return;
  lastRfidCheckMs = now;

  if (!mfrc522.PICC_IsNewCardPresent()) return;
  if (!mfrc522.PICC_ReadCardSerial()) return;

  String uid = uidToHex(mfrc522.uid.uidByte, mfrc522.uid.size);
  Serial.print("RFID: Tag scanned — UID=");
  Serial.println(uid);

  mfrc522.PICC_HaltA();
  mfrc522.PCD_StopCrypto1();

  // Look up tag in Supabase
  String urlPath = "rfid_tags?uid=eq." + uid + "&select=id,assigned_player_id";
  HttpResult res = supabaseGet(urlPath);

  if (!res.success) {
    Serial.println("RFID: Lookup failed (no WiFi or error)");
    return;
  }

  JsonDocument doc;
  deserializeJson(doc, res.body);
  JsonArray arr = doc.as<JsonArray>();

  if (arr.size() == 0) {
    Serial.println("RFID: Unknown tag — not registered in database");
    return;
  }

  String assignedPlayer = arr[0]["assigned_player_id"].as<String>();
  if (assignedPlayer == "null" || assignedPlayer.length() == 0) {
    Serial.println("RFID: Tag registered but not assigned to a player");
    return;
  }

  activePlayerId = assignedPlayer;
  Serial.print("RFID: Active player set to ");
  Serial.println(activePlayerId);

  // Look up player name for display
  String playerUrl = "players?id=eq." + activePlayerId + "&select=first_name,last_name";
  HttpResult pRes = supabaseGet(playerUrl);
  if (pRes.success) {
    JsonDocument pDoc;
    deserializeJson(pDoc, pRes.body);
    JsonArray pArr = pDoc.as<JsonArray>();
    if (pArr.size() > 0) {
      String firstName = pArr[0]["first_name"].as<String>();
      String lastName  = pArr[0]["last_name"].as<String>();
      Serial.print("RFID: Player = ");
      Serial.print(firstName);
      Serial.print(" ");
      Serial.println(lastName);

      // Show on display
      displayDirty = true;
    }
  }

  // POST scan event
  JsonDocument scanDoc;
  scanDoc["team_id"]   = activeTeamId;
  scanDoc["uid"]       = uid;
  scanDoc["device_id"] = nullptr;
  String scanJson;
  serializeJson(scanDoc, scanJson);
  supabasePost("scan_events", scanJson);
}

// ══════════════════════════════════════════════════════════════════════
//  DISPLAY
// ══════════════════════════════════════════════════════════════════════
void setupDisplay() {
  SPI.begin(TFT_SCK, -1, TFT_MOSI, -1);
  tft.init(240, 240, SPI_MODE0);
  tft.setSPISpeed(40000000);
  tft.setRotation(0);
  tft.invertDisplay(true);
  pinMode(TFT_BL, OUTPUT);
  digitalWrite(TFT_BL, HIGH);
  tft.fillScreen(C_BLACK);
}

void updateDisplay() {
  if (!displayDirty) return;
  displayDirty = false;

  tft.fillScreen(C_BLACK);

  if (state == IDLE) {
    tft.setTextColor(C_GREEN);
    tft.setTextSize(3);
    tft.setCursor(72, 10);
    tft.println("READY");

    // Show WiFi status
    tft.setTextSize(1);
    tft.setCursor(6, 38);
    if (wifiConnected) {
      tft.setTextColor(C_GREEN);
      tft.print("WiFi: OK  ");
    } else {
      tft.setTextColor(C_RED);
      tft.print("WiFi: OFF ");
    }

    // Show exercise
    tft.setTextColor(C_CYAN);
    tft.setCursor(6, 52);
    tft.print("Exercise: ");
    tft.setTextColor(C_WHITE);
    tft.print(activeExercise);

    tft.setTextColor(C_WHITE);
    tft.setTextSize(2);
    if (lastSetReps > 0) {
      tft.setCursor(24, 75);
      tft.print("Last set: ");
      tft.print(lastSetReps);
      tft.println(" reps");
    }

    tft.setTextColor(C_GREY);
    tft.setTextSize(1);
    tft.setCursor(30, 190);
    tft.println("'c' = Calibrate");
    tft.setCursor(30, 205);
    tft.println("'s' = Start Set");
    if (calibrated) {
      tft.setTextColor(C_GREEN);
      tft.setCursor(30, 225);
      tft.println("Calibrated");
    }
    return;
  }

  if (state == CALIBRATING) {
    tft.setTextColor(C_YELLOW);
    tft.setTextSize(2);
    tft.setCursor(18, 90);
    tft.println("Calibrating...");
    tft.setTextColor(C_WHITE);
    tft.setCursor(30, 130);
    tft.println("Hold still!");
    return;
  }

  // ── RUNNING state ──
  tft.setTextColor(C_GREEN);
  tft.setTextSize(4);
  tft.setCursor(24, 4);
  tft.print("Rep ");
  tft.println(repCount);

  tft.drawFastHLine(10, 40, 220, C_GREY);

  if (lastRep.repNum == 0) {
    tft.setTextColor(C_YELLOW);
    tft.setTextSize(2);
    tft.setCursor(48, 110);
    tft.println("Waiting...");
    return;
  }

  int y = 50;
  int dy = 25;
  tft.setTextSize(2);

  tft.setTextColor(C_CYAN); tft.setCursor(6, y);
  tft.print("Peak V "); tft.setTextColor(C_WHITE);
  tft.print(lastRep.peakVel, 3); tft.println(" m/s");
  y += dy;

  tft.setTextColor(C_CYAN); tft.setCursor(6, y);
  tft.print("Mean V "); tft.setTextColor(C_WHITE);
  tft.print(lastRep.meanVel, 3); tft.println(" m/s");
  y += dy;

  tft.setTextColor(C_CYAN); tft.setCursor(6, y);
  tft.print("Pk Acc "); tft.setTextColor(C_WHITE);
  tft.print(lastRep.peakAccel, 1); tft.println(" m/s2");
  y += dy;

  tft.setTextColor(C_CYAN); tft.setCursor(6, y);
  tft.print("ROM    "); tft.setTextColor(C_WHITE);
  tft.print(lastRep.romCm, 1); tft.println(" cm");
  y += dy;

  tft.setTextColor(C_CYAN); tft.setCursor(6, y);
  tft.print("Conc   "); tft.setTextColor(C_WHITE);
  tft.print(lastRep.concMs); tft.println(" ms");
  y += dy;

  tft.setTextColor(C_CYAN); tft.setCursor(6, y);
  tft.print("Ecc    "); tft.setTextColor(C_WHITE);
  tft.print(lastRep.eccMs); tft.println(" ms");
  y += dy;

  tft.setTextColor(C_CYAN); tft.setCursor(6, y);
  tft.print("Total  "); tft.setTextColor(C_WHITE);
  tft.print(lastRep.totalMs); tft.println(" ms");
}

// ══════════════════════════════════════════════════════════════════════
//  CALIBRATION
// ══════════════════════════════════════════════════════════════════════
static const int CAL_SAMPLES = 200;
int calCount = 0;
float calSumAx, calSumAy, calSumAz;
float calSumGx, calSumGy, calSumGz;

void startCalibration() {
  state = CALIBRATING;
  calCount = 0;
  calSumAx = calSumAy = calSumAz = 0;
  calSumGx = calSumGy = calSumGz = 0;
  Serial.println("CALIBRATING... Hold device completely still for ~1 second.");
  displayDirty = true;
}

void processCalibrationSample(float ax, float ay, float az, float gx, float gy, float gz) {
  calSumAx += ax; calSumAy += ay; calSumAz += az;
  calSumGx += gx; calSumGy += gy; calSumGz += gz;
  calCount++;

  if (calCount >= CAL_SAMPLES) {
    gex = calSumAx / CAL_SAMPLES;
    gey = calSumAy / CAL_SAMPLES;
    gez = calSumAz / CAL_SAMPLES;
    float mag = sqrtf(gex*gex + gey*gey + gez*gez);

    biasGx = calSumGx / CAL_SAMPLES;
    biasGy = calSumGy / CAL_SAMPLES;
    biasGz = calSumGz / CAL_SAMPLES;

    calibrated = true;
    state = IDLE;

    Serial.print("CAL_DONE,grav_mag=");
    Serial.print(mag, 3);
    Serial.print(",gravDir=(");
    Serial.print(gex/mag, 3); Serial.print(",");
    Serial.print(gey/mag, 3); Serial.print(",");
    Serial.print(gez/mag, 3); Serial.print(")");
    Serial.print(",gyroBias=(");
    Serial.print(biasGx, 2); Serial.print(",");
    Serial.print(biasGy, 2); Serial.print(",");
    Serial.print(biasGz, 2); Serial.println(")");
    Serial.println("READY - Press 's' to START set.");
    displayDirty = true;
  }
}

// ══════════════════════════════════════════════════════════════════════
//  PIPELINE
// ══════════════════════════════════════════════════════════════════════
void resetRepMetrics() {
  concPeakVel = 0;
  concSumVel  = 0;
  concSamples = 0;
  concPeakAccel = 0;
  concDisplacement = 0;
  eccPeakVel  = 0;
  eccSumVel   = 0;
  eccSamples  = 0;
  eccDisplacement = 0;
  dVert = 0;
  repAccelMin = 999; repAccelMax = 0; repAccelSum = 0;
  repGyroMin  = 999; repGyroMax  = 0; repGyroSum  = 0;
  repTotalSamples = 0;
}

void resetPipeline() {
  vVert = 0;
  dVert = 0;
  phase = REST;
  repCount = 0;
  zuptCounter = 0;
  lastRepEndMs = 0;
  smaIndex = 0;
  smaFull = false;
  for (int i = 0; i < SMA_SIZE; i++) smaBuffer[i] = 0;
  resetRepMetrics();
  lastRep.repNum = 0;
  lastMicros = micros();
}

void startSet() {
  if (state == RUNNING) return;
  if (!calibrated) {
    Serial.println("WARNING: Not calibrated. Press 'c' first for best results.");
  }
  state = RUNNING;
  resetPipeline();
  repBufferCount = 0;
  setStartMs = millis();
  setStartedAtISO = getISOTimestamp();
  Serial.println("STARTED_SET");
  Serial.print("  Exercise: "); Serial.println(activeExercise);
  Serial.print("  Player:   "); Serial.println(activePlayerId);
  Serial.println("t_ms,aVert,vVert,dVert,ax,ay,az,gx,gy,gz,rep,phase");
  displayDirty = true;
}

void stopSet() {
  if (state == IDLE) return;
  state = IDLE;
  lastSetReps = repCount;
  Serial.print("STOPPED_SET,total_reps=");
  Serial.println(repCount);
  displayDirty = true;

  // Upload to Supabase
  uploadSet();
}

void bufferRep(float peakVel, float meanVel, float peakAccel, float romCm,
               float concDurMs, float eccDurMs, float timeToPeakMs) {
  if (repBufferCount >= MAX_REPS_PER_SET) {
    Serial.println("WARNING: Rep buffer full (30 reps max)");
    return;
  }
  RepData& r = repBuffer[repBufferCount];
  r.rep_number          = repBufferCount + 1;
  r.mean_velocity       = meanVel;
  r.peak_velocity       = peakVel;
  r.rom_meters          = romCm / 100.0f;       // cm → m
  r.concentric_duration = concDurMs / 1000.0f;   // ms → s
  r.eccentric_duration  = eccDurMs / 1000.0f;    // ms → s
  r.time_to_peak_vel    = timeToPeakMs / 1000.0f; // ms → s
  repBufferCount++;
}

void emitRepSummary() {
  float concMeanVel = (concSamples > 0) ? (concSumVel / (float)concSamples) : 0;
  float concDurMs = concEndMs - concStartMs;
  float eccDurMs  = millis() - eccStartMs;
  float totalDurMs = concDurMs + eccDurMs;
  float romCm = fabs(concDisplacement) * 100.0f;

  if (romCm < MIN_ROM_CM) return;

  repCount++;

  // Serial output (same as v2)
  Serial.print("REP_SUMMARY,");
  Serial.print(repCount);          Serial.print(",");
  Serial.print(concPeakVel, 3);    Serial.print(",");
  Serial.print(concMeanVel, 3);    Serial.print(",");
  Serial.print(concPeakAccel, 3);  Serial.print(",");
  Serial.print(romCm, 1);          Serial.print(",");
  Serial.print((int)concDurMs);    Serial.print(",");
  Serial.print((int)eccDurMs);     Serial.print(",");
  Serial.println((int)totalDurMs);

  float repAccelMean = (repTotalSamples > 0) ? (repAccelSum / (float)repTotalSamples) : 0;
  float repGyroMean  = (repTotalSamples > 0) ? (repGyroSum  / (float)repTotalSamples) : 0;

  Serial.print("REP_SENSORS,");
  Serial.print(repCount);         Serial.print(",");
  Serial.print(repAccelMin, 3);   Serial.print(",");
  Serial.print(repAccelMax, 3);   Serial.print(",");
  Serial.print(repAccelMean, 3);  Serial.print(",");
  Serial.print(repGyroMin, 2);    Serial.print(",");
  Serial.print(repGyroMax, 2);    Serial.print(",");
  Serial.println(repGyroMean, 2);

  // Save for display
  lastRep.repNum    = repCount;
  lastRep.peakVel   = concPeakVel;
  lastRep.meanVel   = concMeanVel;
  lastRep.peakAccel = concPeakAccel;
  lastRep.romCm     = romCm;
  lastRep.concMs    = (int)concDurMs;
  lastRep.eccMs     = (int)eccDurMs;
  lastRep.totalMs   = (int)totalDurMs;

  // Buffer for Supabase upload
  // time_to_peak_vel: estimate as half of concentric duration (rough approximation)
  bufferRep(concPeakVel, concMeanVel, concPeakAccel, romCm,
            concDurMs, eccDurMs, concDurMs * 0.5f);

  displayDirty = true;
}

// ══════════════════════════════════════════════════════════════════════
//  MAIN VBT PROCESSING
// ══════════════════════════════════════════════════════════════════════
void processVBT(float ax, float ay, float az, float gx_raw, float gy_raw, float gz_raw) {
  float gx = gx_raw - biasGx;
  float gy = gy_raw - biasGy;
  float gz = gz_raw - biasGz;

  unsigned long now = micros();
  float dt = (now - lastMicros) * 1e-6f;
  if (dt <= 0 || dt > 0.1f) dt = 0.005f;
  lastMicros = now;

  float gx_rad = gx * DEG_TO_RAD;
  float gy_rad = gy * DEG_TO_RAD;
  float gz_rad = gz * DEG_TO_RAD;

  float new_gex = gex + (gey * gz_rad - gez * gy_rad) * dt;
  float new_gey = gey + (gez * gx_rad - gex * gz_rad) * dt;
  float new_gez = gez + (gex * gy_rad - gey * gx_rad) * dt;

  gex = (1.0f - COMP_ALPHA) * new_gex + COMP_ALPHA * ax;
  gey = (1.0f - COMP_ALPHA) * new_gey + COMP_ALPHA * ay;
  gez = (1.0f - COMP_ALPHA) * new_gez + COMP_ALPHA * az;

  float gmag = sqrtf(gex*gex + gey*gey + gez*gez);
  if (gmag < 0.1f) gmag = G_CONST;
  float ugx = gex / gmag;
  float ugy = gey / gmag;
  float ugz = gez / gmag;

  float aAlongG = ax*ugx + ay*ugy + az*ugz;
  float aVert = aAlongG - G_CONST;

  aVert = smaFilter(aVert);
  if (fabs(aVert) < ACC_DEADBAND) aVert = 0;

  float gyroMag = sqrtf(gx*gx + gy*gy + gz*gz);

  if (fabs(aVert) < ZUPT_ACCEL_THRESH && gyroMag < ZUPT_GYRO_THRESH) {
    zuptCounter++;
  } else {
    zuptCounter = 0;
  }
  bool isStationary = (zuptCounter >= ZUPT_COUNT_THRESH);

  if (isStationary) {
    vVert *= 0.90f;
  } else {
    vVert += aVert * dt;
    vVert *= VEL_DECAY;
  }

  if (vVert >  VEL_CLAMP) vVert =  VEL_CLAMP;
  if (vVert < -VEL_CLAMP) vVert = -VEL_CLAMP;

  if (phase != REST) {
    dVert += vVert * dt;
  }

  float accelMag = sqrtf(ax*ax + ay*ay + az*az);
  if (phase != REST) {
    if (accelMag < repAccelMin) repAccelMin = accelMag;
    if (accelMag > repAccelMax) repAccelMax = accelMag;
    repAccelSum += accelMag;
    if (gyroMag < repGyroMin) repGyroMin = gyroMag;
    if (gyroMag > repGyroMax) repGyroMax = gyroMag;
    repGyroSum += gyroMag;
    repTotalSamples++;
  }

  unsigned long tms = millis();

  switch (phase) {
    case REST: {
      if ((tms - lastRepEndMs) > (unsigned long)MIN_REST_MS && vVert > CONC_START_THRESH) {
        phase = CONCENTRIC;
        concStartMs = tms;
        resetRepMetrics();
        concPeakVel = vVert;
        dVert = 0;
      }
      break;
    }
    case CONCENTRIC: {
      if (vVert > concPeakVel) concPeakVel = vVert;
      if (fabs(aVert) > concPeakAccel) concPeakAccel = fabs(aVert);
      concSumVel += vVert;
      concSamples++;
      concDisplacement = dVert;
      if (vVert < CONC_END_THRESH && (tms - concStartMs) > (unsigned long)MIN_CONC_MS) {
        concEndMs = tms;
        phase = ECCENTRIC;
        eccStartMs = tms;
        eccPeakVel = 0;
      }
      if ((tms - concStartMs) > 5000) {
        phase = REST;
        lastRepEndMs = tms;
      }
      break;
    }
    case ECCENTRIC: {
      if (vVert < eccPeakVel) eccPeakVel = vVert;
      eccSumVel += fabs(vVert);
      eccSamples++;
      eccDisplacement = dVert - concDisplacement;
      bool hasMovedDown = (eccPeakVel < ECC_MOVE_THRESH);
      if (hasMovedDown && fabs(vVert) < ECC_END_THRESH && (tms - eccStartMs) > (unsigned long)MIN_ECC_MS) {
        emitRepSummary();
        lastRepEndMs = tms;
        phase = REST;
      }
      if ((tms - eccStartMs) > 5000) {
        emitRepSummary();
        lastRepEndMs = tms;
        phase = REST;
      }
      break;
    }
  }

  // CSV output
  Serial.print(tms);              Serial.print(",");
  Serial.print(aVert, 4);         Serial.print(",");
  Serial.print(vVert, 4);         Serial.print(",");
  Serial.print(dVert, 4);         Serial.print(",");
  Serial.print(ax, 3);            Serial.print(",");
  Serial.print(ay, 3);            Serial.print(",");
  Serial.print(az, 3);            Serial.print(",");
  Serial.print(gx, 2);            Serial.print(",");
  Serial.print(gy, 2);            Serial.print(",");
  Serial.print(gz, 2);            Serial.print(",");
  Serial.print(repCount);         Serial.print(",");
  Serial.println((int)phase);
}

// ══════════════════════════════════════════════════════════════════════
//  NON-BLOCKING SERIAL COMMAND PARSER
// ══════════════════════════════════════════════════════════════════════
const int CMD_BUF_SIZE = 128;
char cmdBuffer[CMD_BUF_SIZE];
int cmdLen = 0;

void processCommand(const String& cmd) {
  if (cmd.length() == 0) return;

  char first = cmd.charAt(0);

  // Single-char commands
  if (cmd.length() == 1) {
    switch (first) {
      case 'c': case 'C': startCalibration(); return;
      case 's': case 'S': startSet();         return;
      case 'x': case 'X': stopSet();          return;
      case 'd': case 'D': deleteLastSet();    return;
      case 'w': case 'W':
        Serial.println("── Status ──");
        Serial.print("  WiFi:     ");
        Serial.println(WiFi.status() == WL_CONNECTED ? "Connected" : "Disconnected");
        if (WiFi.status() == WL_CONNECTED) {
          Serial.print("  IP:       "); Serial.println(WiFi.localIP());
        }
        Serial.print("  Supabase: "); Serial.println(SUPABASE_URL);
        Serial.print("  Player:   "); Serial.println(activePlayerId);
        Serial.print("  Team:     "); Serial.println(activeTeamId);
        Serial.print("  Exercise: "); Serial.println(activeExercise);
        Serial.print("  State:    ");
        Serial.println(state == IDLE ? "IDLE" : (state == RUNNING ? "RUNNING" : "CALIBRATING"));
        Serial.print("  Time:     "); Serial.println(getISOTimestamp());
        return;
    }
  }

  // Multi-char commands with ':' separator
  int colonIdx = cmd.indexOf(':');
  if (colonIdx > 0) {
    String prefix = cmd.substring(0, colonIdx);
    String value  = cmd.substring(colonIdx + 1);
    value.trim();

    if (prefix == "e" || prefix == "E") {
      activeExercise = value;
      Serial.print("Exercise set to: ");
      Serial.println(activeExercise);
      displayDirty = true;
      return;
    }
    if (prefix == "p" || prefix == "P") {
      activePlayerId = value;
      Serial.print("Player ID set to: ");
      Serial.println(activePlayerId);
      return;
    }
    if (prefix == "t" || prefix == "T") {
      activeTeamId = value;
      Serial.print("Team ID set to: ");
      Serial.println(activeTeamId);
      return;
    }
  }

  Serial.print("Unknown command: ");
  Serial.println(cmd);
  Serial.println("Commands: s, x, c, w, d, e:<name>, p:<uuid>, t:<uuid>");
}

void handleSerialInput() {
  while (Serial.available()) {
    char c = (char)Serial.read();

    if (c == '\n' || c == '\r') {
      if (cmdLen > 0) {
        cmdBuffer[cmdLen] = '\0';
        String cmd = String(cmdBuffer);
        cmd.trim();
        processCommand(cmd);
        cmdLen = 0;
      }
    } else {
      if (cmdLen < CMD_BUF_SIZE - 1) {
        cmdBuffer[cmdLen++] = c;
      }
    }
  }
}

// ══════════════════════════════════════════════════════════════════════
//  ARDUINO SETUP & LOOP
// ══════════════════════════════════════════════════════════════════════
void setup() {
  Serial.begin(115200);
  delay(800);

  Serial.println("╔═══════════════════════════════════╗");
  Serial.println("║   VBT RFID IMU v3                 ║");
  Serial.println("║   WiFi + Supabase + RC522 RFID    ║");
  Serial.println("╚═══════════════════════════════════╝");

  // Display (FSPI)
  setupDisplay();

  // WiFi
  connectWiFi();

  // IMU (I2C)
  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(400000);
  delay(20);

  uint8_t who = 0;
  if (!readReg(REG_WHO_AM_I, who)) {
    Serial.println("IMU: WHO_AM_I read failed.");
  } else {
    Serial.print("IMU: WHO_AM_I=0x");
    Serial.println(who, HEX);
  }
  setupQMI8658();

  // RFID (HSPI)
  setupRFID();

  Serial.println();
  Serial.println("Commands:");
  Serial.println("  s           Start set");
  Serial.println("  x           Stop set + upload");
  Serial.println("  c           Calibrate IMU");
  Serial.println("  e:<name>    Change exercise");
  Serial.println("  p:<uuid>    Change player ID");
  Serial.println("  t:<uuid>    Change team ID");
  Serial.println("  d           Delete last set");
  Serial.println("  w           Show status");
  Serial.println();

  lastMicros = micros();
  displayDirty = true;
}

void loop() {
  handleSerialInput();
  updateDisplay();

  // WiFi auto-reconnect (only when not in a set)
  if (state == IDLE) {
    checkWiFiReconnect();
    handleRFIDScan();
    delay(10);
    return;
  }

  float ax, ay, az, gx, gy, gz;
  if (!readIMU(ax, ay, az, gx, gy, gz)) return;

  if (state == CALIBRATING) {
    processCalibrationSample(ax, ay, az, gx, gy, gz);
    delay(5);
    return;
  }

  if (state == RUNNING) {
    processVBT(ax, ay, az, gx, gy, gz);
  }

  delay(2);  // ~200Hz
}
